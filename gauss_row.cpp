#include <iostream>
#include <math.h>
#include <stdlib.h>
#include <fstream>

using namespace std;

int main() {
    int n, m;
    system("chcp 65001");
    ifstream f("matrix.txt");
    f >> n;
    m = n + 1;                      //Расширенная матрица
    double **A = new double *[n+1]; //Выделяем память под строки
    for (int i = 1; i <= n; i++)
        A[i] = new double[m+1];     //Под столбцы
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            f >> A[i][j];
        }
    }
    f.close();

    //Вывод на экран
    cout << "Matrix A: " << endl;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++)
            cout << A[i][j] << " ";
        cout << endl;
    }
    cout << endl;

    /*Метод Гаусса c выбором главного элемента*/
/*------------------------------------------Прямой ход----------------------------------------*/
/*Исключения Гаусса основаны на идее последовательного исключения
  переменных по одной до тех пор, пока не останется только одно уравнение с
  одной переменной в левой части. Затем это уравнение решается относительно
  единственной переменной. Таким образом, систему уравнений приводят к
  треугольной (ступенчатой) форме. Для этого среди элементов первого столбца матрицы
  выбирают ненулевой (а чаще максимальный) элемент и перемещают его на крайнее верхнее
  положение перестановкой строк. Затем нормируют все уравнения, разделив его
  на коэффициент a[i,1], где i – номер столбца.                                        */
    int index; int q=0;
    for (int l = 1; l < n; l++) {
    // Поиск строки с максимальным a[i][k]
        double max = abs(A[l][l]);        //Первый элемент - кандидат на максимальный
        index = l;                        //Первая строчка кандидат на строчку с максимальным элементом
        for (int i = l + 1; i <= n; i++) {
            if (abs(A[i][l]) > max) {     //Если элемент по модулю больше максимального
                max = abs(A[i][l]);       //Запоминаем его
                index = i;                //Запоминаем индекс строки с ним
            }
        }
        for (int j = 1; j <= m; j++) {     //В этом цикле через доп. переменную меняем строки
            double temp = A[l][j];
            A[l][j] = A[index][j];
            A[index][j] = temp;
        }

        q++;
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= m; j++)
                if (abs(A[i][j]) < 0.00000001) A[i][j] = 0;

      cout << "Матрица А после "<<q <<" шага: " << endl;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++)
                cout << A[i][j] << " ";
            cout << endl;
        }
        cout << endl;

        double tmp;
            for (int i = l + 1; i <= n; i++) {
                tmp = A[i][l] / A[l][l];
                for (int j = m; j >= l; j--) //Считаем от последнего эл-та в строке, т.е. вектора b
                    A[i][j] -= tmp * A[l][j];
        }
    }

/*------------------------------------------Прямой ход----------------------------------------*/

/*-------------------------------Обратный ход-------------------------------*/
/*    Обратная подстановка предполагает
      подстановку полученного на предыдущем шаге значения
      переменной xn в предыдущие уравнения:                              */

    double *x = new double[n+1];
    x[n] = A[n][m]/A[n][n];
    for (int i = n - 1; i >= 1; i--) {
        x[i] = A[i][m];
        for (int j = i + 1; j <= n; j++)
            x[i] -= A[i][j] * x[j];
        x[i] = x[i]/A[i][i];
    }

/*-------------------------------Обратный ход-------------------------------*/

    //Выводим решения
    ofstream out ("answer.txt");
    for (int i = 1; i <= n; i++){
        cout << x[i] << " ";
        out << x[i] << ' ';
    }
    cout << endl;
    out.close();
    delete[] A;
    delete[] x;
    return 0;
}